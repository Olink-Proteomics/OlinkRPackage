
# Main Function -----------------------------------------------------------

#' Clean Olink NPX Data Frame
#'
#' @description
#' This function applies a series of cleaning steps to an NPX dataset based on
#' the results from [`check_npx()`]. It removes samples/assays with errors,
#' control samples, internal control assays to prepare the dataset for
#' downstream analysis.
#'
#' The cleaning pipeline performs the following steps:
#'
#' 1. **Remove invalid OlinkIDs**: Any assays flagged as having invalid OlinkIDs
#' are excluded.
#' 2. **Remove assays with all NA values**: Assays that have no quantifiable data
#' across all samples are removed.
#' 3. **Remove duplicate SampleIDs**: Samples with duplicate identifiers are
#' excluded to ensure unique observations.
#' 4. **Remove control sample types**: Samples identified as controls (e.g.,
#' `"SAMPLE_CONTROL"`, `"PLATE_CONTROL"`) are removed based on the
#' `SampleType` column.
#' 5. **Remove samples failing QC**: Samples that failed Olink internal quality
#' control are excluded.
#' 6. **Remove control-like SampleIDs**: Samples whose `SampleID` matches a
#' user-defined regular expression (e.g., containing "control") are excluded.
#' 7. **Remove internal control assays**: Assays used for internal controls
#' (e.g., `"ext_ctrl"`, `"inc_ctrl"`) are removed based on `AssayType`.
#'
#' @author
#' Kang Dong
#'
#' @param df A `"tibble"` or `"arrow"` object loaded from `read_npx()`.
#' @param check_npx_log A list object generated by [`check_npx()`], containing
#' metadata used in cleaning decisions.
#' @param out_df Output format. `"tibble"` (default) returns a tibble; `"arrow"`
#' returns an Arrow Table.
#' @param control_sample_types_regx A character vector of regex patterns for
#' identifying control sample types in the `SampleType` column.
#' @param control_assay_types_regx A character vector of regex patterns for
#' identifying internal control assay types in the `AssayType` column.
#' @param control_sample_id_regex A character vector of regex patterns for
#' identifying control-like SampleIDs in the `SampleID` column.
#' Default is `NULL`.
#'
#' @returns A cleaned NPX dataset in either tibble or Arrow Table format,
#' depending on `out_df`.
#'
#' @examples
#' \dontrun {
#' # Example 1. Run clean_npx() to check multiple errors
#' df <- dplyr::tibble(
#'   SampleID = c("A", "B", "C", "D", "E", "F", "F", "control_F"),
#'   OlinkID = c("OID123456",
#'               rep("OID12345", 3L),
#'               rep("OID11111", 4L)),
#'   NPX = c(1, NA, NA, NA, 5, 6, 7, 8),
#'   PlateID = rep("plate1", 8L),
#'   SampleType = c(
#'     rep("SAMPLE", 5L),
#'     "SAMPLE_CONTROL",
#'     "PLATE_CONTROL",
#'     "NEGATIVE_CONTROL"
#'   ),
#'   AssayType = c(
#'     rep("assay", 3L),
#'     rep("ext_ctrl", 5L)
#'   ),
#'   QC_Warning = c(
#'     rep("FAIL", 3L),
#'     rep("PASS", 5L)
#'   )
#' )
#'
#' log <- OlinkAnalyze::check_npx(df)
#' outcome <- OlinkAnalyze:clean_npx(df,
#'                                   check_npx_log = log,
#'                                   control_sample_id_regex = c("control"))
#'
#' # Example 2. Test default setting of clean_npx()
#' npx_df <- OlinkAnalyze::npx_data1
#' log <- OlinkAnalyze::check_npx(npx_df)
#' clean_df <- OlinkAnalyze::clean_npx(npx_df, log)
#'
#' # re-check the clean_df
#' recheck_log <- OlinkAnalyze::check_npx(clean_df)
#' }

clean_npx <- function(df,
                      check_npx_log,
                      out_df = "tibble",
                      control_sample_types_regx = c("SAMPLE_CONTROL",
                                                    "PLATE_CONTROL",
                                                    "NEGATIVE_CONTROL"),
                      control_assay_types_regx = c("ext_ctrl",
                                                   "inc_ctrl",
                                                   "amp_ctrl"),
                      control_sample_id_regex = NULL
                      ) {

  # Step 0: Validate inputs
  check_is_dataset(df = df, error = TRUE)

  if (!inherits(check_npx_log, "list")) {
    cli::cli_abort(
      "{.arg check_npx_log} must be the result of the {.fn check_npx} function."
      )
  }

  cli::cli_h2("Starting {.fn clean_npx} pipeline")

  # Step 1: Remove invalid Olink IDs
  cli::cli_h3("Step 1: Removing assays with invalid OlinkIDs")
  df <- clean_invalid_oid(df,
                          check_npx_log = check_npx_log,
                          out_df = out_df)

  # Step 2: Remove assays with all NA values
  cli::cli_h3("Step 2: Removing assays with all NA values")
  df <- clean_assay_na(df,
                       check_npx_log = check_npx_log,
                       out_df = out_df)

  # Step 3: Remove duplicate sample IDs
  cli::cli_h3("Step 3: Removing duplicate SampleIDs")
  df <- clean_duplicate_sample_id(df,
                                  check_npx_log = check_npx_log,
                                  out_df = out_df)

  # Step 4: Remove control samples based on sample type
  cli::cli_h3("Step 4: Removing control samples based on sample type")
  df <- clean_sample_type(df,
                          check_npx_log = check_npx_log,
                          control_sample_types = control_sample_types_regx,
                          out_df = out_df)

  # Step 5: Remove samples that failed QC
  cli::cli_h3("Step 5: Removing samples that failed QC")
  df <- clean_sample_qc(df,
                        check_npx_log = check_npx_log,
                        out_df = out_df)

  # Step 6: Remove control-like SampleIDs
  cli::cli_h3("Step 6: Removing control-like SampleIDs")
  df <- clean_control_sample_id(df,
                                check_npx_log = check_npx_log,
                                control_sample_id = control_sample_id_regex,
                                out_df = out_df)

  # Step 7: Remove internal control assays
  cli::cli_h3("Step 7: Removing internal control assays")
  df <- clean_assay_type(df,
                         check_npx_log = check_npx_log,
                         control_assay_types = control_assay_types_regx,
                         out_df = out_df)

  # Final output
  cli::cli_h2("Completed {.fn clean_npx} pipeline")

  if (out_df == "arrow") {
    cli::cli_alert_success("Cleaning complete. Returning Arrow Table.")
  } else {
    cli::cli_alert_success("Cleaning complete. Returning tibble.")
  }

  return(df |>
           convert_read_npx_output(out_df = out_df))

}



# Support Functions -------------------------------------------------------


#' Remove assays with only NA values
#'
#' @description
#' This function filters out rows from a `tibble` or `arrow` object where the assay
#' identifier (e.g.,`OlinkID`) matches those listed in `check_npx_log$assay_na`,
#' which contains assays composed entirely of NA values. It uses CLI messaging
#' to report which assays were removed.
#'
#' @author
#' Kang Dong
#'
#' @param df A `tibble` or `arrow` object  loads from `read_npx()`, including a
#'  column identified by `check_npx_log$col_names$olink_id`.
#' @param check_npx_log A list generated by `check_npx()` function, containing:
#'   - `assay_na`: a character vector of `OlinkID` to be excluded.
#'   - `col_names$olink_id`: the column name in `df` that holds the `OlinkID`.
#' @param out_df Output format of the cleaned data. Options: `"tibble"` (default)
#' or `"arrow"`.
#'
#' @return A filtered `tibble` or `arrow` object with rows corresponding to NA-only
#' assays removed.
#'
#' @examples
#' \dontrun{
#' # Example 1: Exclude 1 assay with only NA values
#' df <- dplyr::tibble(
#'   SampleID = c("A", "B", "C", "D"),
#'   OlinkID = rep("OID12345", 4L),
#'   SampleType = rep("SAMPLE", 4L),
#'   NPX = NA,
#'   PlateID = rep("plate1", 4L),
#'   QC_Warning = rep("Pass", 4L),
#'   LOD = rnorm(4L)
#' )
#'
#' log <- OlinkAnalyze::check_npx(df)
#' out <- OlinkAnalyze::clean_assay_na(df, check_npx_log = log)
#' }

clean_assay_na <- function(df,
                           check_npx_log,
                           out_df = "tibble") {

  # If there are no assays with all NA values, skip filtering
  if (length(check_npx_log$assay_na) == 0) {
    cli::cli_alert_info(
    "No assays with only NA values found. Returning original data frame."
    )
    return(
      df |>
        convert_read_npx_output(out_df = out_df)
    )
  }

  # Prepare column and values to filter
  col_olink_id <- rlang::sym(check_npx_log$col_names$olink_id)
  olink_ids_to_remove <- check_npx_log$assay_na

  # CLI message listing excluded assays
  cli::cli_alert_warning(
    "Excluding {length(olink_ids_to_remove)} assay{?s} with only NA values:
    {paste(olink_ids_to_remove, collapse = ', ')}"
  )

  # Exclude assays with only NA values
  df_cleaned <- df |>
    dplyr::collect() |>
    dplyr::filter(!(!!col_olink_id %in% olink_ids_to_remove))

  cli::cli_alert_success(
  "Removed rows for assays with only NA values.Returning cleaned data frame."
  )

  # Convert output to desired format (tibble or arrow)
  return(
    df_cleaned |>
      convert_read_npx_output(out_df = out_df)
  )
}


#' Remove assays with invalid OlinkID
#'
#' @description
#' This function filters out rows from a NPX data where the assay identifier
#' column (e.g.,`OlinkID`) matches values listed in `check_npx_log$oid_invalid`,
#' which identifies invalid or malformed assay identifiers. Uses CLI messages to
#' inform users of what was excluded.
#'
#' @author
#' Kang Dong
#'
#' @param df A `tibble` or `arrow` object loaded from `read_npx()`, containing a column
#' specified by `check_npx_log$col_names$olink_id`.
#' @param check_npx_log A list returned by `check_npx()`, containing:
#'   - `oid_invalid`: a character vector of invalid assay identifiers to be removed.
#'   - `col_names$olink_id`: the name of the column in `df` that holds the assay IDs.
#' @param out_df Output format of the cleaned data.
#' Options: `"tibble"` (default) or `"arrow"`.
#'
#' @return A filtered `tibble` or `arrow` object with invalid OlinkIDs removed.
#'
#' @examples
#' \dontrun{
#' # Example 1: Exclude invalid OlinkID using clean_invalid_oid()
#' df <- dplyr::tibble(
#'   SampleID = c("A", "B", "C", "D"),
#'   OlinkID = c(rep("OID12345", 2L), rep("OID123456", 2L)),
#'   SampleType = rep("SAMPLE", 4L),
#'   NPX = c(rep(1.0, 2L), rep(2.0, 2L)),
#'   PlateID = rep("plate1", 4L),
#'   QC_Warning = rep("Pass", 4L),
#'   LOD = rep(1.0, 4L)
#' )
#'
#' log <- suppressWarnings(OlinkAnalyze::check_npx(df))
#' out <- OlinkAnalyze::clean_invalid_oid(df, check_npx_log = log)
#' }

clean_invalid_oid <- function(df,
                              check_npx_log,
                              out_df = "tibble") {

  # Check if there are any invalid OlinkIDs to remove
  if (length(check_npx_log$oid_invalid) == 0) {
    cli::cli_alert_info(
      "No invalid OlinkIDs found. Returning original data frame."
    )
    return(
      df |>
        convert_read_npx_output(out_df = out_df)
    )
  }

  # Prepare column and values to filter
  col_olink_id <- rlang::sym(check_npx_log$col_names$olink_id)
  olink_ids_to_remove <- check_npx_log$oid_invalid

  # Inform user of which assays will be excluded
  cli::cli_alert_warning(
    "Excluding {length(olink_ids_to_remove)} assay{?s} with invalid OlinkIDs:
    {paste(olink_ids_to_remove, collapse = ', ')}"
  )

  # Remove rows where the OlinkID is invalid
  df_cleaned <- df |>
    dplyr::collect() |>
    dplyr::filter(!(!!col_olink_id %in% olink_ids_to_remove))

  # Confirmation message
  cli::cli_alert_success(
    "Removed rows for assays with invalid OlinkIDs. Returning cleaned data frame."
  )

  # Return cleaned data frame in desired format
  return(
    df_cleaned |>
      convert_read_npx_output(out_df = out_df)
  )
}


#' Remove samples with duplicate SampleIDs
#'
#' @description
#' This function filters out rows from a NPX data where the sample identifier
#' (e.g., `SampleID`) appears more than once. The duplicate SampleIDs are
#' identified in `check_npx_log$sample_id_dups`, which is generated by the
#' `check_npx()` function. Uses CLI messages to inform users of exclusions.
#'
#' @author
#' Kang Dong
#'
#' @param df A `tibble` or `arrow` object loaded from `read_npx()`, containing a column
#' specified by `check_npx_log$col_names$sample_id`.
#' @param check_npx_log A list returned by `check_npx()`, containing:
#'   - `sample_id_dups`: a character vector of duplicate SampleIDs to be removed.
#'   - `col_names$sample_id`: the name of the column in `df` that holds
#'   the SampleIDs.
#' @param out_df Output format of the cleaned data.
#' Options: `"tibble"` (default) or `"arrow"`.
#'
#' @return A filtered tibble or arrow object with duplicated SampleIDs removed.
#'
#' @examples
#' \dontrun {
#' # Example 1: Exclude 1 sample with duplicate SampleID
#' df <- dplyr::tibble(
#'   SampleID = c("A", "B", "C", "C"),
#'   OlinkID = c(rep("OID12345", 2L), rep("OID12345", 2L)),
#'   SampleType = rep("SAMPLE", 4L),
#'   NPX = c(rep(1.0, 2L), rep(2.0, 2L)),
#'   PlateID = rep("plate1", 4L),
#'   QC_Warning = rep("Pass", 4L),
#'   LOD = rep(1.0, 4L)
#' )
#' log <- OlinkAnalyze::check_npx(df)
#' clean_df <- OlinkAnalyze::clean_duplicate_sample_id(df, log)
#' }

clean_duplicate_sample_id <- function(df,
                                      check_npx_log,
                                      out_df = "tibble") {

  # Check if there are any duplicate SampleIDs to remove
  if (length(check_npx_log$sample_id_dups) == 0) {
    cli::cli_alert_info(
      "No duplicate SampleIDs found. Returning original data frame."
    )
    return(
      df |>
        convert_read_npx_output(out_df = out_df)
    )
  }

  # Prepare column and values to filter
  col_sample_id <- rlang::sym(check_npx_log$col_names$sample_id)
  sample_ids_to_remove <- check_npx_log$sample_id_dups

  # Inform user about excluded SampleIDs
  cli::cli_alert_warning(
    "Excluding {length(sample_ids_to_remove)} sample{?s} with duplicate SampleIDs:
    {paste(sample_ids_to_remove, collapse = ', ')}"
  )

  # Filter out rows with duplicate SampleIDs
  df_cleaned <- df |>
    dplyr::collect() |>
    dplyr::filter(!(!!col_sample_id %in% sample_ids_to_remove))

  # Success message
  cli::cli_alert_success(
    "Removed rows with duplicate SampleIDs. Returning cleaned data frame."
  )

  # Convert and return the output in the desired format
  return(
    df_cleaned |>
      convert_read_npx_output(out_df = out_df)
  )
}


#' Remove control samples based on sample type
#'
#' @description
#' This function filters out rows from an NPX data where the sample type
#' column matches one of the defined control types using regular expressions
#' (case-insensitive).
#'
#' @author
#' Kang Dong
#'
#' @param df A `tibble` or `arrow` object loaded from `read_npx()`.
#' @param check_npx_log A list returned from `check_npx()`, containing:
#'   - `col_names$sample_type`: name of the column in `df` that identifies
#'   sample type.
#' @param control_sample_types A character vector of control sample types to
#' exclude. Regular expression matching is used. Default is c("SAMPLE_CONTROL",
#' "PLATE_CONTROL", "NEGATIVE_CONTROL").
#' @param out_df Output format: either "tibble" (default) or "arrow".
#'
#' @return A cleaned tibble or arrow object with control sample removed.
#' @examples
#' \dontrun {
#' # Example 1: Run clean_sample_type() with default setting to remove
#' # control samples
#' df <- dplyr::tibble(
#'   SampleID = c("A", "B", "C", "D"),
#'   OlinkID = rep("OID12345", 4L),
#'   SampleType = c("SAMPLE",
#'                  "SAMPLE_CONTROL",
#'                  "PLATE_CONTROL",
#'                  "NEGATIVE_CONTROL"),
#'   NPX = rep(1, 4L),
#'   PlateID = rep("plate1", 4L),
#'   QC_Warning = rep("Pass", 4L),
#'   LOD = rep(1, 4L)
#' )
#' log <- OlinkAnalyze::check_npx(df)
#' clean_df <- OlinkAnalyze::clean_sample_type(df, log)
#'
#' # Example 2: Run control_sample_types = NULL to keep control samples, and
#' # return the unchanged data
#' clean_df <- OlinkAnalyze::clean_sample_type(df, log, control_sample_types = NULL)
#' }

clean_sample_type <- function(df,
                              check_npx_log,
                              control_sample_types = c("SAMPLE_CONTROL",
                                                       "PLATE_CONTROL",
                                                       "NEGATIVE_CONTROL"),
                              out_df = "tibble") {

  # Early exit if control_sample_types is NULL or sample_type column is missing
  if (is.null(control_sample_types) ||
      !"sample_type" %in% names(check_npx_log$col_names)) {
    if (is.null(control_sample_types)) {
      cli::cli_alert_info(
        "No control sample types provided. Returning data unchanged."
        )
    } else {
      cli::cli_alert_warning(c(
        "No column name found for {.var sample_type} in {.code check_npx_log$col_names}.",
        "i" = "Returning data unchanged."
      ))
    }
    return(
      df |>
        convert_read_npx_output(out_df = out_df)
    )
  }

  # Get the sample type column name
  col_sample_type <- check_npx_log$col_names$sample_type

  # Combine control types into a single case-insensitive regex pattern
  ctrl_pattern <- paste0("(?i)^(",
                         paste(control_sample_types, collapse = "|"),
                         ")$")

  # Identify rows to remove using regex
  rows_to_remove <- stringr::str_detect(df[[col_sample_type]], ctrl_pattern)
  n_controls <- sum(rows_to_remove, na.rm = TRUE)

  # Inform removed rows
  cli::cli_inform(c(
    "Removing {n_controls} row{?s} of control sample{?s}.",
    "i" = "Matching sample type: {paste(control_sample_types, collapse = ', ')}"
  ))

  # Remove matched rows and return
  df_cleaned <- df[!rows_to_remove, ] |> dplyr::collect()

  return(
    df_cleaned |>
      convert_read_npx_output(out_df = out_df)
  )
}


#' Remove Internal Control Assays by Assay Type
#'
#' @description
#' This function filters out rows from an NPX data where the assay type
#' matches any of the specified control assay types (e.g., `ext_ctrl`,
#' `inc_ctrl`, `amp_ctrl`). Matching is case-insensitive and uses regular
#' expressions via `stringr::str_detect()`. Informative CLI messages report the
#' number and type of rows removed.
#'
#' @author
#' Kang Dong
#'
#' @param df A `tibble` or `arrow` object loaded from `read_npx()`, containing
#' an assay type column.
#' @param check_npx_log A list generated by `check_npx()` that includes:
#'   - `col_names$assay_type`: the name of the column holding assay type
#'   information.
#' @param control_assay_types A character vector of internal control assay
#' types to remove. Default is `c("ext_ctrl", "inc_ctrl", "amp_ctrl")`.
#' @param out_df The class of output data frame. Options are `"tibble"` or
#' `"arrow"`. Default: `"tibble"`.
#'
#' @return A filtered tibble or arrow object with internal control assay
#' rows removed.
#'
#' #' @examples
#' \dontrun {
#'
#' df <- dplyr::tibble(
#'   SampleID = c("A", "B", "C", "D"),
#'   OlinkID = rep("OID12345", 4L),
#'   NPX = rep(1, 4L),
#'   PlateID = rep("plate1", 4L),
#'   QC_Warning = rep("Pass", 4L),
#'   LOD = rep(1, 4L),
#'   AssayType = c("assay",
#'                 "ext_ctrl",
#'                 "inc_ctrl",
#'                 "amp_ctrl")
#' )
#'
#' log <- OlinkAnalyze::check_npx(df)
#'
#' # Example 1: Run clean_assay_type() as default. Internal control assay
#' are removed
#' clean_df <- OlinkAnalyze::clean_assay_type(df, log)
#'
#' # Example 2: Set control_assay_types = NULL. Return unchanged data
#' clean_df <- OlinkAnalyze::clean_assay_type(df, log, control_assay_types = NULL)
#' }

clean_assay_type <- function(df,
                             check_npx_log,
                             control_assay_types = c("ext_ctrl",
                                                     "inc_ctrl",
                                                     "amp_ctrl"),
                             out_df = "tibble") {

  # Early exit if control_assay_types is NULL or assay_type column is missing
  if (is.null(control_assay_types) ||
      !"assay_type" %in% names(check_npx_log$col_names)) {
    if (is.null(control_assay_types)) {
      cli::cli_alert_info(
        "No control assay types provided. Returning data unchanged."
        )
    } else {
      cli::cli_alert_warning(c(
        "No column name found for {.var assay_type} in {.code check_npx_log$col_names}.",
        "i" = "Returning data unchanged."
      ))
    }
    return(
      df |>
        convert_read_npx_output(out_df = out_df)
    )
  }

  # Extract column name for assay type
  col_assay_type <- check_npx_log$col_names$assay_type

  # Construct case-insensitive regex pattern for control assay types
  ctrl_pattern <- paste0("(?i)^(",
                         paste(control_assay_types, collapse = "|"),
                         ")$")

  # Identify rows matching control assay types
  rows_to_remove <- stringr::str_detect(df[[col_assay_type]], ctrl_pattern)
  n_controls <- sum(rows_to_remove, na.rm = TRUE)

  # Inform user
  cli::cli_inform(c(
    "Removing {n_controls} row{?s} of internal control assay{?s}.",
    "i" = "Matching assay type{?s}: {paste(control_assay_types, collapse = ', ')}"
  ))

  # Filter out control assay rows
  df_cleaned <- df[!rows_to_remove, ] |>
    dplyr::collect()

  # Return result in desired output format
  return(
    df_cleaned |>
      convert_read_npx_output(out_df = out_df)
  )
}


#' Remove Samples That Failed QC
#'
#' @description
#' This function removes rows from an NPX data where the QC warning column
#' contains the term `"fail"` (case-insensitive). These rows typically represent
#' samples that failed quality control checks. The function uses
#' `stringr::str_detect()` for pattern matching and returns the cleaned data in
#' the desired output format (`"tibble"` or `"arrow"`).
#'
#' @author
#' Kang Dong
#'
#' @param df A `tibble` or `arrow` object loaded using `read_npx()`, containing
#' a QC status column.
#' @param check_npx_log A list generated by `check_npx()` that includes:
#'   - `col_names$qc_warning`: the name of the column indicating QC status.
#' @param out_df A string specifying the output format of the data frame.
#'   Options are `"tibble"` or `"arrow"`. Default is `"tibble"`.
#'
#' @returns A filtered tibble or arrow object with samples that failed QC removed.
#'
#' @example
#' \dontrun {
#' # Example 1: Remove 1 sample that failed sample QC
#'
#' df <- dplyr::tibble(
#'   SampleID = c("A", "B", "C", "D"),
#'   OlinkID = rep("OID12345", 4L),
#'   NPX = rep(1, 4L),
#'   PlateID = rep("plate1", 4L),
#'   QC_Warning = c(rep("Pass", 3L), "FAIL"),
#'   LOD = rep(1, 4L)
#' )
#'
#' log <- OlinkAnalyze::check_npx(df)
#' clean_df <- OlinkAnalyze::clean_sample_qc(df, log)
#' }

clean_sample_qc <- function(df,
                            check_npx_log,
                            out_df = "tibble") {

  # Check if qc_warning column name is defined in check_npx_log
  if (!"qc_warning" %in% names(check_npx_log$col_names)) {
    cli::cli_alert_warning(c(
      "No column name found for {.var qc_warning} in
      {.code check_npx_log$col_names}.",
      "i" = "Returning data unchanged."
    ))
    return(
      df |>
        convert_read_npx_output(out_df = out_df)
    )
  }

  # Extract column name for QC warning
  col_sample_qc <- check_npx_log$col_names$qc_warning

  # Identify rows where QC warning contains "fail" (case-insensitive)
  rows_to_remove <- stringr::str_detect(df[[col_sample_qc]], "(?i)fail")
  n_controls <- sum(rows_to_remove, na.rm = TRUE)

  # Inform user about rows being removed
  cli::cli_inform(c(
    "Removing {n_controls} row{?s} of sample{?s} failed QC."
  ))

  # Filter out failed samples and return cleaned data
  df_cleaned <- df[!rows_to_remove, ] |> dplyr::collect()

  return(
    df_cleaned |>
      convert_read_npx_output(out_df = out_df)
  )
}


#' Remove Control Samples Based on Sample ID Pattern
#'
#' @description
#' This function removes rows from a NPX data where the `sample_id` matches a
#' regular expression pattern indicating customer control samples. This is useful
#' for filtering out technical controls or customer control samples based on their
#' SampleID.
#'
#' @author
#' Kang Dong
#'
#' @param df A `tibble` or `arrow` object loaded using `read_npx()`, including
#' a sample ID column.
#' @param check_npx_log A list generated by `check_npx()` that includes:
#'   - `col_names$sample_id`: the column name in `df` identifying sample IDs.
#' @param control_sample_id A character vector of regex strings
#' (case-insensitive) used to match control sample IDs, e.g., c("control").
#' Default is: `NULL`.
#' @param out_df Output format of the returned data frame.
#'   Options: `"tibble"` or `"arrow"`. Default is `"tibble"`.
#'
#' @returns A filtered data frame with control sample IDs removed.
#' \dontrun{
#' # Example 1: use npx_data1 to check that clean_control_sample_id() works
#' log <- OlinkAnalyze::npx_data1 |>
#'   OlinkAnalyze::check_npx() |>
#'   suppressWarnings()
#'
#' out <- OlinkAnalyze::clean_control_sample_id(npx_data1,
#'                                              check_npx_log = log,
#'                                              control_sample_id = "control")
#'
#' # Example 2: check default setting of clean_control_sample_id(). Return data
#' # unchanged.
#' out <- OlinkAnalyze::clean_control_sample_id(npx_data1,
#'                                              check_npx_log = log,
#'                                              control_sample_id = NULL)
#' }

clean_control_sample_id <- function(df,
                                    check_npx_log,
                                    control_sample_id = NULL,
                                    out_df = "tibble") {

  # Early exit check
  if (is.null(control_sample_id) ||
      !"sample_id" %in% names(check_npx_log$col_names)) {
    if (is.null(control_sample_id)) {
      cli::cli_alert_info(
        "No control sample ID pattern provided. Returning data unchanged."
        )
    } else {
      cli::cli_alert_warning(c(
        "No column name found for {.var sample_id} in {.code check_npx_log$col_names}.",
        "i" = "Returning data unchanged."
      ))
    }
    return(
      df |>
        convert_read_npx_output(out_df = out_df)
    )
  }

  # Extract sample_id column name
  col_sample_id <- check_npx_log$col_names$sample_id

  # Combine all regex patterns into one case-insensitive expression
  ctrl_pattern <- paste0("(?i)", paste(control_sample_id, collapse = "|"))

  # Identify rows to remove
  rows_to_remove <- stringr::str_detect(df[[col_sample_id]], ctrl_pattern)
  n_controls <- sum(rows_to_remove, na.rm = TRUE)

  # Inform user of removed rows
  cli::cli_inform(c(
    "Removing {n_controls} row{?s} of control sample{?s} based on sample ID pattern.",
    "i" = "Matching pattern: {paste(control_sample_id, collapse = ', ')}"
  ))

  # Filter and return the cleaned data
  df_cleaned <- df[!rows_to_remove, ] |> dplyr::collect()

  return(
    df_cleaned |>
      convert_read_npx_output(out_df = out_df)
  )
}
